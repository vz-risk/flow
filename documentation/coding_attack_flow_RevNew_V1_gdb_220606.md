## Coding Attack Flow

0. It is beneficial to have a namespace for, at a minimum, the actions and assets.  A namespace is basically a schema someone else maintains.  Two popular examples are VERIS (actions and assets) and ATT&CK (actions).  If possible it's good to also have 'attribute' covered by a namespace as well as other things you want standardized (such as assets within your organization, or schemas provided by a vendor.)  You may also need a namespace for the flow itself (though the flow builder UI handles this silently).  More advanced orgs may use a namespace for all of their orgs flows, such as https://example.com/flows, an absolute namespace such as urn:absolute:flows, or an absolute namespace for the specific flow such as urn:absolute:flow1#.
1. Identify each action take by the action, the asset it effected and the attribute it compromised in order.  (If the attribute is unknown, use 'compromised'.)
  1. Create the action instance. Note: ID, Name, description, and logic operator are the only required fields.
    0. id: If using the flow builder this will be automatically assigned.  If not, you should either assign a random id within the flow's namespace (see step 0) such as generated by https://www.uuidgenerator.net/, or a simple numbering such as "action1".  This is an _instance_ of an action happening. If the action was 'Used credentials' and you give it the id 'Used creds', you won't have an ID to give the next instance of 'Used credentials' in this flow.  Instead, we will indicate that it's 'Used creds' by it's name, description, and reference.
  	1. name: Literal name describing the action. (For VERIS, it would be the description.  For mitre attack, it would be the name.)
  	2. description: A short narrative about this instance of the action
  	3. reference: a URI reference to the the class of action (For example https://attack.mitre.org/techniques/T1566/001/ for ATT&CK or https://veriscommunity.net/attack-flow/action.malware.variety.Phishing for VERIS)
  	4. logic_operator: Use 'and' or 'or' if unsure. This indicates how to treat preceeding actions.  Did all of them need to succeed before this action could occur (and) or only one needed to succeed (or)? This field is critical for attack simulation but relatively simple for attack documentation.
  	- (Note: below fields are not required.)
  	5. logic_operator_language: Assumed to be boolean and/or, but if you did something fancier in the logic operator, indicate the language here.
  	6. timestamp: A RFC 3339 date-time string.  If you don't know the actual times, just number them as seconds from unix epoc: ("1970-01-01T00:00:01", "1970-01-01T00:00:02", "1970-01-01T00:00:03", etc).  This field is used to create the temporal order of actions once they've occurred.
  	7. succeeded: Likely 1 (true) if coding an incident though possibly 0 (false).
  	8. confidence: If you have any doughts about the action, you can give a score here. 1 means no doubts, 0 means no trust.
  2. Create the asset instance with the state set to the attribute compromised. (If you aren't sure what attribute to put here, use "compromised")
  3. Create an edge from the action to the asset with a type of the attribute (If you aren't sure what attribute to put here, use state_change.compromised).  If you are using the builder it will assign an ID automatically.  If not, you may either give it a random ID as with actions above, give it a generic id such as 'asset1', or, if you know what the asset is specifically (because, for example, you are documenting an incident within your own organization), give it the ID of the URI of the asset in your organization-specific namespace.
2. Repeat step 1 for the next action.  link the asset(s) that came before this action to this asset with the an edge of the type of the attribute.  (If you're unsure what to put here, use state.compromised).  Note, this edge means that the previous action was necessary to accomplish this one.  If the actors could have done the action earlier but just didn't, link to the earlier asset.  The timestamp will still reflect the order the actions occurred in.
3. Add properties to the flow.  Often we know a great deal more about the case.  We want to document these properties.  They come in two forms: Object Properties and Data Properties.
  1. Adding Object Properties: This connects our flow to the greater context of what we know.
  	1. The first place to add Object Properties are to assets.  Likely you know the asset type.  If using a namespace such as VERIS that has asset, types, create a property of type rdf:type that points to the appropriate asset type (e.g. veris:server).  Do this by creating a property in the graph for the namespace asset variety.  Then create an edge of type "rdf:type" pointing from the asset in the flow to the asset variety.
  	You may also know what the actual asset is if the incident is within your organization.  If you did not give the asset an ID of the specific asset, you can create a property node for the asset from your organization's namspace and then connect from the flow asset to the org asset with an edge of type owl:sameAs.
  	2. Additional properties.  such as: 
  		* the discovery method of the action 
  		* the actor who took the action (or even just creating a actor as a property and pointing all the actions to it to indicate that the actions were taken by the same actor)
  		* the impact of the action in currency or time
  		* details about the victim
  		* details about the mitigations
  	No matter what it is, it can be connected to an action, an asset, or even another property.  The type of the edge will vary based on the schema you're using.  For example, you might use "veris:impact.overall_rating" as a type for an edge pointing at the property "veris:Damaging".
  	Actor can be a great example of describing one property with another property.  You may create a property named "actor1".  Then find out it's a specific threat group.  Create a property for that threat group in the appropriate namespace (e.g. atk:apt29) and then an edge of type owl:equivalentClass to indicate that actor1 was APT 29.  Once you've linked to the threat actor, you inherit the knowledge graph associated with that threat actor in it's namespace!
  	3. Add properties to the flow.  While not supported by flow builder, you can add additional properties to the flow node itself the same way you would any other node (with an edge of the appropriate type pointed at a property node of the appropriate property type). The benefit of doing this is that it can be used to indicate that a property applies to every action and asset in the flow, saving you creating extra edges.  For example, instead of pointing each action at the same actor (as suggested above), point the flow at the actor.
  2. Adding Data Properties:  Data properties are strings, numbers, etc.  They are values, not 'things'.  If you need to add notes about an action or attribute, a data property could be used.  If you need to note an indicator such as a MD5 hash, a data property could be used.  Just like with Object Properties, they can point from an action, asset, property, or flow to the data property.  It's highly recommended to only use data properties sparingly.  Because they are free-form text, rather than classes of things, they're harder to process as structured data.

The bulk of the work in building the flow will be in step 1 (and 2) as you create the flow.  Most the fields are intuitive with experience and will go quickly.